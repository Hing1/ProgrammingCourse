# 其他 C++ 特性

## 6.1. 引用参数

1. 所有按引用传递的参数必须加上 const
2. 在输入形参中用 const T* 指针比 const T& 更明智
    · 可能会传递空指针.
    · 函数要把指针或对地址的引用赋值给输入形参.

## 6.2. 右值引用

1. 只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 std::forward.
2. 右值引用能实现可移动但不可拷贝的类型
3. 要高效率地使用某些标准库类型, 例如 std::unique_ptr, std::move 是必需的
4. 只在定义移动构造函数与移动赋值操作时使用右值引用

## 6.3. 函数重载

1. 若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹

## 6.4. 缺省参数

1. 我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。
2. 使用情况
    · 位于 .cc 文件里的静态函数或匿名空间函数，毕竟只能在局部文件里调用该函数
    · 可以在构造函数里用缺省参数，毕竟不可能取得它们的地址
    · 可以用来模拟变长数组

## 6.5. 变长数组和 alloca()

1. 不允许使用变长数组和 alloca().
2. 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.
3. 改用更安全的分配器（allocator），就像 std::vector 或 std::unique_ptr<T[]>

## 6.6. 友元

1. 允许合理的使用友元类及友元函数
2. 相对于将类成员声明为 public, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时

## 6.7. 异常

1. 不使用 C++ 异常
2. 异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant 注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或 Init() 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态
3. 在现有函数中添加 throw 语句时，您必须检查所有调用点
4. 异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回
5. 启用异常会增加二进制文件数据，延长编译时间

## 6.8. 运行时类型识别

1. 禁止使用 RTTI
2. RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 typeid 或者 dynamic_cast 完成

## 6.9. 类型转换

1. 使用 C++ 的类型转换, 如 static_cast<>(). 不要使用 int y = (int)x 或 int y = int(x) 等转换方式;
2. 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时
3. 用 const_cast 去掉 const 限定符.
4. 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.

## 6.10. 流

1. 只在记录日志时使用流
2. 流用来替代 printf() 和 scanf()
3. 除非是日志接口需要，不要使用流, 除非是日志接口需要
4. 大多数决定采用 printf + read/write

## 6.11. 前置自增和自减

1. 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符
2. 不考虑返回值的话, 前置自增 (++i) 通常要比后置自增 (i++) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝.
3. 对简单数值 (非对象), 两种都无所谓

## 6.12. const 用法

1. 我们强烈建议你在任何可能的情况下都要使用 const. 此外有时改用 C++11 推出的 constexpr 更好。
2. 在声明的变量或参数前加上关键字 const 用于指明变量值不可被篡改
3. 为类中的函数加上 const 限定符表明该函数不会修改类成员变量的状态
4. const 是入侵性的: 如果你向一个函数传入 const 变量, 函数原型声明中也必须对应 const 参数
5. 尽可能将函数声明为 const. 访问函数应该总是 const. 其他不会修改任何数据成员, 未调用非 const 函数, 不会返回数据成员非 const 指针或引用的函数也应该声明成 const
6. 如果数据成员在对象构造之后不再发生变化, 可将其定义为 const
7. 将 const 放在前面才更易读, 因为在自然语言中形容词 (const) 是在名词 (int) 之前

## 6.13. constexpr 用法

1. 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化

## 6.14. 整型

1. 如果程序中需要不同大小的变量, 可以使用 <stdint.h> 中长度精确的整型, 如 int16_t.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 int64_t
2. C++ 没有指定整型的大小. 通常人们假定 short 是 16 位, int 是 32 位, long 是 32 位, long long 是 64 位.
3. 不要使用 uint32_t 等无符号整型，尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.

## 6.15. 64 位下的可移植性

1. 代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记
2. 你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体
3. 创建 64 位常量时使用 LL 或 ULL 作为后缀

## 6.16. 预处理宏

1. 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.
2. 使用宏, 尽可能遵守
    ·不要在 .h 文件中定义宏.
    ·在马上要使用时才进行 #define, 使用后要立即 #undef.
    ·不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称
    ·不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.
    ·不要用 ## 处理函数，类和变量的名字

## 6.17. 0, nullptr 和 NULL

1. 整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 '\0'
2. C++11 项目用 nullptr; C++03 项目则用 NULL
3. 一些 C++ 编译器对 NULL 的定义比较特殊，可以输出有用的警告，特别是 sizeof(NULL) 就和 sizeof(0) 不一样

## 6.18. sizeof

1. 尽可能用 sizeof(varname) 代替 sizeof(type)

## 6.19. auto

1. 用 auto 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方
2. C++11 中，若变量被声明成 auto, 那它的类型就会被自动匹配成初始化表达式的类型

    ```cpp
    vector<string> v;
    auto s1 = v[0];  // 创建一份 v[0] 的拷贝。
    const auto& s2 = v[0];  // s2 是 v[0] 的一个引用。
    ```

    ```cpp
    sparse_hash_map<string, int>::iterator iter = m.find(val);
    auto iter = m.find(val);
    ```

3. auto 和 C++11 列表初始化的合体令人摸不着头脑

    ```cpp
    auto x(3);  // 圆括号。x 是 int
    auto y{3};  // 大括号。y 是 std::initializer_list<int>
    ```

## 6.20. 列表初始化

1. 可以用列表初始化

    ```cpp
    struct Point { int x; int y; };
    Point p = {1, 2};
    ```

2. 千万别直接列表初始化 auto 变量

    ```cpp
    auto d = {1.23};        // d 即是 std::initializer_list<double>
    auto d = double{1.23};  // 善哉 -- d 即为 double, 并非 std::initializer_list.
    ```

## 6.21. Lambda 表达式

1. 适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来

## 6.22. 模板编程

1. 不要使用复杂的模板编程
2. 模板编程能够实现非常灵活的类型安全的接口和极好的性能, 一些常见的工具比如Google Test, std::tuple, std::function 和 Boost.Spirit. 这些工具如果没有模板是实现不了的

## 6.23. Boost 库

1. 只使用 Boost 中被认可的库

## 6.24. C++11

1. C++11 特性除了个别情况下，可以用一用
    ·尾置返回类型，比如用 auto foo() -> int 代替 int foo(). 为了兼容于现有代码的声明风格
    ·编译时合数 <ratio>, 因为它涉及一个重模板的接口风格
    ·<cfenv> 和 <fenv.h> 头文件，因为编译器尚不支持
    ·默认 lambda 捕获

## 译者（acgtyrant）笔记

1. friend 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 .cc 文件加以定义
2. 友元可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件
3. 友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后
4. 注意初始化 const 对象时，必须在初始化的同时值初始化
5. 用断言代替无符号整型类型，深有启发
6. auto 在涉及迭代器的循环语句里挺常用

## 菜鸟笔记

1. 前置自增 (++i) 通常要比后置自增 (i++) 效率更高
2. const应该放在声明的最前面
3. <stdint.h> 定义了 int16_t, uint32_t, int64_t 等整型
4. 要非常小心的对待结构体对齐
5. 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.
