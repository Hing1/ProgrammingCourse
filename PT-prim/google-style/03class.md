# class

## 3.1. 构造函数的职责

不要在构造函数中调用虚函数</br>
如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 bool IsValid() 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法

## 3.2. 隐式类型转换

不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 explicit 关键字
隐式类型转换允许一个某种类型 (称作 源类型) 的对象被用于需要另一种类型 (称作 目的类型) 的位置, 例如, 将一个 int 类型的参数传递给需要 double 类型的函数.

## 3.3. 可拷贝类型和可移动类型

1. 如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用
2. 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义
3. 所有可拷贝对象也是可移动的
4. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成 对象切割 .
5. 拷贝构造函数是隐式调用的
6. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义
7. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作
8. 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类)
9. 如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之.

```cpp
MyClass(const MyClass&) = delete;
MyClass& operator=(const MyClass&) = delete;
```

## 3.4. 结构体 VS. 类

1. 仅当只有数据成员时使用 struct, 其它一概使用 class；如果拿不准, 就用 class
2. 为了和 STL 保持一致, 对于仿函数等特性可以不用 class 而是使用 struct
3. 类和结构体的成员变量使用不同的 命名规则.

## 3.5. 继承

1. 使用组合常常比使用继承更合理，尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo.
2. 如果使用继承的话, 定义为 public 继承.
3. 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称.
4. 子类不能重写父类的非虚函数
5. 对于可能被子类访问的成员函数, 不要过度使用 protected 关键字. 注意, 数据成员都必须是 私有的.

## 3.6. 多重继承

1. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类

## 3.7. 接口

1. 接口是指满足特定条件的类, 这些类以 Interface 为后缀
2. 当一个类满足以下要求时, 称之为纯接口:</br>
    · 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数).</br>
    · 没有非静态数据成员.</br>
    · 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected.</br>
    · 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.</br>
3. 接口类不能被直接实例化, 因为它声明了纯虚函数.
4. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数
5. 以 Interface 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 多重继承 尤其重要

## 3.8. 运算符重载

1. 除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量
2. 不要重载 &&, ||, , 或一元运算符 & 。不要重载 operator""
3. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的。如, 如果你重载了 <, 那么请将所有的比较运算符都进行重载
4. 不要为了避免重载操作符而走极端. 比如说, 应当定义 ==, =, 和 << 而不是 Equals(), CopyFrom() 和 PrintTo().

## 3.9. 存取控制

将 所有 数据成员声明为 private, 除非是 static const 类型成员

## 3.10. 声明顺序

1. 声明次序: public -> protected -> private;
2. 在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.

## 译者笔记

1. 不在构造函数中做太多逻辑相关的初始化
2. 为避免隐式转换, 需将单参数构造函数声明为 explicit
3. 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现

## 菜鸟笔记

1. 拷贝构造函数和赋值操作要同时给出或同时不给
2. 当只有数据成员时使用 struct, 其它都使用 class
3. 组合常常比使用继承更合理
4. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承
5. 定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的
